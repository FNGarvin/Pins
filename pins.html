<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Game of Pins</title>
    <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container { text-align: center; background: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); width: 100%; max-width: 600px; }
        #konva-container { margin: 20px auto; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9; cursor: crosshair; }
        .controls { margin-bottom: 20px; display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 10px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; background-color: #007aff; color: white; transition: background-color 0.2s; }
        button:hover { background-color: #0056b3; }
        #status { font-size: 1.2em; font-weight: bold; min-height: 25px; color: #333; }
        footer { margin-top: 20px; font-size: 0.8em; color: #888; }
        a { color: #007aff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); }
        .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; border-radius: 10px; width: 90%; max-width: 500px; position: relative; }
        .modal-content h2 { margin-top: 0; }
        .close-button { color: #aaa; position: absolute; top: 10px; right: 20px; font-size: 28px; font-weight: bold; cursor: pointer; }
        
        /* --- DEBUG PANEL --- */
        #debug-log {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 250px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            border: 1px solid #555;
            border-radius: 5px;
            overflow-y: scroll;
            padding: 5px;
            z-index: 2000;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <h1>The Game of Pins</h1>
        <div class="controls">
            <label>Difficulty:</label>
            <select id="difficulty">
                <option value="novice">Novice</option>
                <option value="intermediate" selected>Intermediate</option>
                <option value="expert">Expert</option>
            </select>
            <button id="restart-btn">New Game</button>
            <button id="rules-btn">How to Play</button>
        </div>
        <div id="status">Start a new game!</div>
        <div id="konva-container"></div>
    </div>
    
    <footer>
        Game created by Gemini &amp; FNGarvin. Released under the MIT License.
        <a href="https://github.com/FNGarvin/Pins" target="_blank" rel="noopener noreferrer">View on GitHub</a>
    </footer>

    <div id="rules-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>How to Play Pins</h2>
            <ul>
                <li>The game starts with three rows of pins (3, 5, and 7).</li>
                <li>On your turn, you must remove at least one pin.</li>
                <li>Click and drag to draw a selection box over the pins you wish to remove.</li>
                <li>All selected pins must be from the same row and next to each other (contiguous).</li>
                <li>The player who is forced to take the very last pin on the board **loses** the game.</li>
            </ul>
        </div>
    </div>
    
    <div id="debug-log"></div>

    <script>
        // --- Global Config & State ---
        const INITIAL_ROWS = [3, 5, 7];
        let boardState = [];
        let isPlayerTurn = false;
        let gameActive = false;
        let selectionRect;
        let x1, y1;

        // --- Konva Setup ---
        const container = document.querySelector('#konva-container');
        const stage = new Konva.Stage({ container: 'konva-container', width: container.clientWidth, height: 300 });
        const layer = new Konva.Layer();
        stage.add(layer);
        
        // --- DOM Elements & Debug ---
        const statusDisplay = document.getElementById('status');
        const restartButton = document.getElementById('restart-btn');
        const rulesButton = document.getElementById('rules-btn');
        const difficultySelector = document.getElementById('difficulty');
        const rulesModal = document.getElementById('rules-modal');
        const closeModalButton = document.querySelector('.close-button');
        const debugLogDiv = document.getElementById('debug-log');
        
        function debugLog(message) {
            debugLogDiv.innerHTML += `> ${message}<br>`;
            debugLogDiv.scrollTop = debugLogDiv.scrollHeight;
        }

        // --- AI & Game Logic (Unchanged) ---
        const ai = { getMove: (d,b) => { switch (d) { case 'intermediate': return Math.random()<0.6?ai.expert(b):ai.novice(b); case 'expert': return ai.expert(b); default: return ai.novice(b);}}, novice: (b) => {const m=gameLogic.getAllPossibleMoves(b); return m[Math.floor(Math.random()*m.length)];}, expert: (b) => {const m=gameLogic.getAllPossibleMoves(b); for(let i=m.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[m[i],m[j]]=[m[j],m[i]];} for(const move of m){const n=gameLogic.applyMove(b,move); const a=n.flat(); const e=a.every(b=>b===1); if(e){if(a.length%2===1)return move;}else{if(gameLogic.getNimSum(n)===0)return move;}} return m[0]||null;}};
        const gameLogic = { getAllPossibleMoves: (s) => {const m=[]; s.forEach((r,ri)=>{r.forEach((bs,bi)=>{for(let c=1;c<=bs;c++){for(let st=0;st<=bs-c;st++){m.push({rowIdx:ri,blockIdx:bi,start:st,count:c});}}});}); return m;}, applyMove: (s,m) => {const{rowIdx:ri,blockIdx:bi,start:st,count:c}=m; const n=JSON.parse(JSON.stringify(s)); const bs=n[ri][bi]; n[ri].splice(bi,1); const l=st; const r=bs-(st+c); if(l>0)n[ri].push(l); if(r>0)n[ri].push(r); n[ri].sort((a,b)=>a-b); return n.filter(r=>r.length>0);}, getNimSum: (s)=>{const a=s.flat(); return a.length>0?a.reduce((sum,v)=>sum^v,0):0;}};

        // --- Rendering & Game Flow ---
        function drawBoard() {
            layer.destroyChildren(); 
            const pinWidth=20, pinHeight=40, pinSpacing=10, rowSpacing=60;
            const boardWidth=stage.width();
            let y=60;
            boardState.forEach((row,rowIdx)=>{
                const totalRowWidth=row.reduce((sum,size)=>sum+size*pinWidth+(size-1)*pinSpacing,0)+(row.length-1)*(pinSpacing*2);
                let x=(boardWidth-totalRowWidth)/2;
                row.forEach((blockSize,blockIdx)=>{
                    for(let i=0;i<blockSize;i++){
                        const pin=new Konva.Rect({x:x,y:y,width:pinWidth,height:pinHeight,fill:'#007aff',stroke:'#0056b3',strokeWidth:1,cornerRadius:5,id:`pin-${rowIdx}-${blockIdx}-${i}`});
                        pin.setAttr('gameData',{rowIdx,blockIdx,pinInBlockIdx:i});
                        layer.add(pin);
                        x+=pinWidth+pinSpacing;
                    }
                    x+=pinSpacing*2;
                });
                y+=rowSpacing;
            });
            layer.batchDraw();
        }

        function processPlayerMove(pinsToRemove) {
            debugLog(`Processing ${pinsToRemove.length} selected pins.`);
            if (pinsToRemove.length === 0) return;
            const firstPinData = pinsToRemove[0].getAttr('gameData');
            const targetRow = firstPinData.rowIdx;
            const targetBlock = firstPinData.blockIdx;
            const indices = pinsToRemove.map(p => p.getAttr('gameData').pinInBlockIdx).sort((a,b)=>a-b);
            
            let isValid = true;
            for(const pin of pinsToRemove) { const data = pin.getAttr('gameData'); if(data.rowIdx!==targetRow || data.blockIdx!==targetBlock) isValid=false; }
            for(let i=0; i<indices.length-1; i++) { if(indices[i+1]!==indices[i]+1) isValid=false; }
            
            if (!isValid) {
                debugLog("Move invalid!");
                statusDisplay.textContent = "Invalid move. Pins must be from the same contiguous block.";
                setTimeout(() => { if(isPlayerTurn) statusDisplay.textContent = "Your turn."; }, 2000);
                return;
            }

            debugLog("Move is valid. Applying...");
            isPlayerTurn = false;
            const move = { rowIdx: targetRow, blockIdx: targetBlock, start: indices[0], count: indices.length };

            pinsToRemove.forEach(pin => { new Konva.Tween({ node: pin, duration: 0.5, opacity: 0, onFinish: () => pin.destroy() }).play(); });
            setTimeout(() => {
                boardState = gameLogic.applyMove(boardState, move);
                if (gameLogic.getAllPossibleMoves(boardState).length === 0) endGame('CPU');
                else triggerCpuTurn();
            }, 550);
        }

        function triggerCpuTurn() {
            statusDisplay.textContent = "CPU is thinking...";
            setTimeout(() => {
                const difficulty = difficultySelector.value;
                const move = ai.getMove(difficulty, boardState);
                if (!move) { endGame('Player'); return; }
                const pinsToRemove = [];
                layer.find('Rect').forEach(pin => {
                    const data = pin.getAttr('gameData');
                    if (data.rowIdx === move.rowIdx && data.blockIdx === move.blockIdx && data.pinInBlockIdx >= move.start && data.pinInBlockIdx < move.start + move.count) {
                        pinsToRemove.push(pin);
                    }
                });
                pinsToRemove.forEach(pin => { new Konva.Tween({ node: pin, duration: 0.5, opacity: 0, onFinish: () => pin.destroy() }).play(); });
                setTimeout(() => {
                    boardState = gameLogic.applyMove(boardState, move);
                    if (gameLogic.getAllPossibleMoves(boardState).length === 0) endGame('Player');
                    else { isPlayerTurn = true; statusDisplay.textContent = "Your turn."; drawBoard(); }
                }, 550);
            }, 1200);
        }

        function startGame() {
            debugLogDiv.innerHTML = ""; // Clear debug log
            debugLog("Starting new game...");
            gameActive = true;
            boardState = INITIAL_ROWS.map(size => [size]);
            isPlayerTurn = true;
            statusDisplay.textContent = "Your turn.";
            drawBoard();
        }

        function endGame(winner) {
            gameActive = false; isPlayerTurn = false;
            statusDisplay.textContent = `Game Over! ${winner} wins!`;
            debugLog(`Game Over! ${winner} wins!`);
        }

        // --- Event Listeners ---
        restartButton.addEventListener('click', startGame);
        rulesButton.addEventListener('click', () => { rulesModal.style.display = "block"; });
        closeModalButton.addEventListener('click', () => { rulesModal.style.display = "none"; });
        window.addEventListener('click', (event) => { if (event.target == rulesModal) rulesModal.style.display = "none"; });

        stage.on('mousedown touchstart', (e) => {
            if (!isPlayerTurn || !gameActive) return;
            e.evt.preventDefault();
            x1 = stage.getPointerPosition().x;
            y1 = stage.getPointerPosition().y;
            selectionRect = new Konva.Rect({
                fill: 'rgba(0,122,255,0.2)', stroke: '#007aff', strokeWidth: 1,
            });
            layer.add(selectionRect);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!selectionRect) return;
            e.evt.preventDefault();
            const x2 = stage.getPointerPosition().x;
            const y2 = stage.getPointerPosition().y;
            selectionRect.setAttrs({
                x: Math.min(x1, x2), y: Math.min(y1, y2),
                width: Math.abs(x2 - x1), height: Math.abs(y2 - y1),
            });
            layer.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!selectionRect) return;
            e.evt.preventDefault();
            debugLog("Mouse up event triggered.");
            
            // DEFINITIVE FIX: Use local coordinates from the selectionRect object itself
            // instead of relying on any page-relative calculations.
            const selectionBox = selectionRect.getAttrs();
            debugLog(`Selection Box: x:${selectionBox.x.toFixed(0)}, y:${selectionBox.y.toFixed(0)}, w:${selectionBox.width.toFixed(0)}, h:${selectionBox.height.toFixed(0)}`);

            const intersectedPins = [];
            layer.find('Rect').forEach(pin => {
                // Ensure we don't check the selection rect against itself
                if (pin === selectionRect) return;
                
                // Use the reliable haveIntersection utility with local coordinates
                if (Konva.Util.haveIntersection(selectionBox, pin.getAttrs())) {
                    intersectedPins.push(pin);
                    debugLog(`  -> Intersection with ${pin.id()}`);
                }
            });
            
            selectionRect.destroy();
            layer.draw();
            selectionRect = null;
            
            processPlayerMove(intersectedPins);
        });
        
        statusDisplay.textContent = 'Select a difficulty and press "New Game".';
    </script>
</body>
</html>

